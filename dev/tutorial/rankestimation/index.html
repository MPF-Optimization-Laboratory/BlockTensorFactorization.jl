<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rank Estimation · BlockTensorFactorization.jl</title><meta name="title" content="Rank Estimation · BlockTensorFactorization.jl"/><meta property="og:title" content="Rank Estimation · BlockTensorFactorization.jl"/><meta property="twitter:title" content="Rank Estimation · BlockTensorFactorization.jl"/><meta name="description" content="Documentation for BlockTensorFactorization.jl."/><meta property="og:description" content="Documentation for BlockTensorFactorization.jl."/><meta property="twitter:description" content="Documentation for BlockTensorFactorization.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BlockTensorFactorization.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickguide/">Quick Guide</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../decompositionmodels/">Decomposition Models</a></li><li><a class="tocitem" href="../constraints/">Constrained Factorization</a></li><li><a class="tocitem" href="../blockupdateorder/">Block Update Order</a></li><li><a class="tocitem" href="../iterationstats/">Iteration Stats</a></li><li><a class="tocitem" href="../multiscale/">Multiscale Factorization</a></li><li class="is-active"><a class="tocitem" href>Rank Estimation</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Estimating-Curvature"><span>Estimating Curvature</span></a></li><li><a class="tocitem" href="#How-do-these-methods-work?"><span>How do these methods work?</span></a></li></ul></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/types/">Types</a></li><li><a class="tocitem" href="../../reference/functions/">Functions</a></li><li><a class="tocitem" href="../../reference/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Rank Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rank Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/main/docs/src/tutorial/rankestimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Rank-Estimation"><a class="docs-heading-anchor" href="#Rank-Estimation">Rank Estimation</a><a id="Rank-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Rank-Estimation" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>In some applications, we may have a tenor we believe to be closely approximated by a low rank tenor, but do not know what rank to use. In this setting, use <code>rank_detect_factorize</code> rather than <code>factorize</code> without a <code>rank=R</code> keyword. The estimated rank will be added to <code>kwargs</code>, and the <code>decomposition</code> at this rank returned.</p><pre><code class="language-julia hljs">R = 3
T = Tucker1((10, 10, 10), R)
Y = array(T)
options = (model=Tucker1, curvature_method=splines) # default values
decomposition, stats, kwargs, final_rel_errors = rank_detect_factorize(Y; options...)

@assert kwargs[:rank] == R</code></pre><p>The rank will be estimated by factorizing the input tensor at every possible rank from 1 up to the maximum rank and recording the relative error. We can pick the rank which balances small error (good fit) and small rank (low complexity). Our criteria is the rank which maximizes the curvature of the error vs. rank function, or in the case of the <code>:breakpoints</code> method, a proxy for the curvature.</p><p>Note <code>rank_detect_factorize</code> also returns the stats and final relative errors of each rank tested.</p><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.rank_detect_factorize-tutorial-rankestimation"><a class="docstring-binding" href="#BlockTensorFactorization.Core.rank_detect_factorize-tutorial-rankestimation"><code>BlockTensorFactorization.Core.rank_detect_factorize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rank_detect_factorize(Y; kwargs...)</code></pre><p>Wraps <code>factorize()</code> with rank detection.</p><p>Selects the rank that maximizes the standard curvature of the Relative Error (as a function of rank).</p><p><strong>Keywords</strong></p><ul><li><code>online_rank_estimation</code>: <code>false</code>. Set to <code>true</code> to stop testing larger ranks after the first peak in curvature</li><li><code>curvature_method</code>: <code>:splines</code>. Can also pick <code>:finite_differences</code> (faster but less accurate) or <code>circles</code> (fastest and smallest memory but more sensitive to results from <code>factorize</code>). Set to <code>:breakpoints</code> to pick the rank <code>R</code> that minimizes least-squares error in the model <code>f(r) = a + b(min(r, R) - R) + c(max(r, R) - R)</code> and the errors.</li><li><code>model</code>: <code>Tucker1</code>. Only rank detection with <code>Tucker1</code> and <code>CPDecomposition</code> is currently implemented</li><li><code>max_rank</code>: <code>max_possible_rank(Y, model)</code>. Test ranks from <code>1</code> up to <code>max_rank</code>. Defaults to largest possible rank under the model</li><li><code>rank</code>: <code>nothing</code>. If a rank is passed, rank detection is ignored and <code>factorize(Y; kwargs...)</code> is called</li></ul><p>Any other keywords from <a href="../../reference/functions/#BlockTensorFactorization.Core.factorize-Tuple{Any}"><code>factorize</code></a>, full list given by <a href="../../reference/functions/#BlockTensorFactorization.Core.default_kwargs-Tuple{Any}"><code>default_kwargs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/rankdetection.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.max_possible_rank-tutorial-rankestimation"><a class="docstring-binding" href="#BlockTensorFactorization.Core.max_possible_rank-tutorial-rankestimation"><code>BlockTensorFactorization.Core.max_possible_rank</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">max_possible_rank(Y, model)</code></pre><p>Returns the maximum rank possible <code>Y</code> could have under the <code>model</code>.</p><p>For matrices <code>I × J</code> this is <code>1:min(I, J)</code>. This is can be extended to tensors for different type of decompositions.</p><p>Tucker-1 rank is <code>≤ min(I, prod(J1,...,JN))</code> for tensors <code>I × J1 × … × JN</code>.</p><p>The CP-rank is <code>≤ minimum_{n} (prod(I1,...,IN) / In)</code> for tensors <code>I1 × … × IN</code> in general. Although some shapes have have tighter upper bounds. For example, <code>2 × I × I</code> tensors over ℝ have a maximum rank of <code>floor(3I/2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/rankdetection.jl#L76-L89">source</a></section></details></article><div class="admonition is-success" id="Tip-522bf09ade591889"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-522bf09ade591889" title="Permalink"></a></header><div class="admonition-body"><p>If you run <code>rank_detect_factorize</code> with different methods and get the same rank, you can feel more confident in the detected rank.</p></div></div><h2 id="Estimating-Curvature"><a class="docs-heading-anchor" href="#Estimating-Curvature">Estimating Curvature</a><a id="Estimating-Curvature-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-Curvature" title="Permalink"></a></h2><p>This package has implemented a few methods for estimating curvature. These are the following list of methods.</p><pre><code class="language-julia hljs">:finite_differences
:circles
:splines</code></pre><p>We can also use the following curvature-proxy methods.</p><pre><code class="language-julia hljs">:breakpoints</code></pre><p>They can be passed to <code>curvature</code> and <code>standard_curvature</code> as a <code>method</code> keyword, or <code>rank_detect_factorize</code> with the <code>curvature_method</code> keyword.</p><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.curvature-tutorial-rankestimation"><a class="docstring-binding" href="#BlockTensorFactorization.Core.curvature-tutorial-rankestimation"><code>BlockTensorFactorization.Core.curvature</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">curvature(y::AbstractVector{&lt;:Real}; method=:finite_differences)</code></pre><p>Approximates the signed curvature of a function given evenly spaced samples.</p><p><strong>Possible <code>method</code>s</strong></p><ul><li><code>:finite_differences</code>: Approximates first and second derivative with 3rd order finite differences. See <a href="../../reference/functions/#BlockTensorFactorization.Core.d_dx-Tuple{AbstractVector{&lt;:Real}}"><code>d_dx</code></a> and <a href="../../reference/functions/#BlockTensorFactorization.Core.d2_dx2-Tuple{AbstractVector{&lt;:Real}}"><code>d2_dx2</code></a>.</li><li><code>:splines</code>: Curvature of a third order spline. See <a href="#BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline"><code>d_dx_and_d2_dx2_spline</code></a>.</li><li><code>:circles</code>: Inverse radius of a circle through rolling three points. See <a href="#BlockTensorFactorization.Core.circle_curvature"><code>circle_curvature</code></a>.</li><li><code>:breakpoints</code>: WARNING does not compute a value that approximates the curvature of a continuous function. Computes the inverse least-squares error of <code>f.(eachindex(y); z)</code> and <code>y</code> for all <code>z in eachindex(y)</code> where <code>f(x; z) = a + b(min(x, z) - z) + c(max(x, z) - z)</code>. Useful if <code>y</code> looks like two lines. See <a href="#BlockTensorFactorization.Core.breakpoint_curvature"><code>breakpoint_curvature</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L147-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.standard_curvature-tutorial-rankestimation"><a class="docstring-binding" href="#BlockTensorFactorization.Core.standard_curvature-tutorial-rankestimation"><code>BlockTensorFactorization.Core.standard_curvature</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">standard_curvature(y::AbstractVector{&lt;:Real}; method=:finite_differences)</code></pre><p>Approximates the signed curvature of a function, scaled to the unit box <span>$[0,1]^2$</span>.</p><p>Assumes the function is 1 at 0 and (after x dimension is scaled) 0 at 1.</p><p>See <a href="../../reference/functions/#BlockTensorFactorization.Core.curvature-Tuple{AbstractVector{&lt;:Real}}"><code>curvature</code></a>.</p><p><strong>Possible <code>method</code>s</strong></p><ul><li><code>:finite_differences</code>: Approximates first and second derivative with 3rd order finite differences. See <a href="../../reference/functions/#BlockTensorFactorization.Core.d_dx-Tuple{AbstractVector{&lt;:Real}}"><code>d_dx</code></a> and <a href="../../reference/functions/#BlockTensorFactorization.Core.d2_dx2-Tuple{AbstractVector{&lt;:Real}}"><code>d2_dx2</code></a>.</li><li><code>:splines</code>: Curvature of a third order spline. See <a href="#BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline"><code>d_dx_and_d2_dx2_spline</code></a>.</li><li><code>:circles</code>: Inverse radius of a circle through rolling three points. See <a href="#BlockTensorFactorization.Core.circle_curvature"><code>circle_curvature</code></a>.</li><li><code>:breakpoints</code>: WARNING does not compute a value that approximates the curvature of a continuous function. Computes the inverse least-squares error of <code>f.(eachindex(y); z)</code> and <code>y</code> for all <code>z in eachindex(y)</code> where <code>f(x; z) = a + b(min(x, z) - z) + c(max(x, z) - z)</code>. Useful if <code>y</code> looks like two lines. See <a href="#BlockTensorFactorization.Core.breakpoint_curvature"><code>breakpoint_curvature</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L175-L190">source</a></section></details></article><p>These methods have been specialized to typical relative error vs. rank curves. We assume a relative error of <span>$1$</span> at rank <span>$0$</span> since the only rank <span>$0$</span> tenor is the <span>$0$</span> tenor. And that the relative error at the maximum possible rank is <span>$0$</span>, and stays zero if we try to use a larger rank.</p><h2 id="How-do-these-methods-work?"><a class="docs-heading-anchor" href="#How-do-these-methods-work?">How do these methods work?</a><a id="How-do-these-methods-work?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-these-methods-work?" title="Permalink"></a></h2><h3 id="Finite-Differences"><a class="docs-heading-anchor" href="#Finite-Differences">Finite Differences</a><a id="Finite-Differences-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Differences" title="Permalink"></a></h3><p>We approximate the first and second derivatives separately with three point finite differences and calculate the curvature with the formula</p><p class="math-container">\[k(x) = \frac{y&#39;&#39;(x)}{(1 + y&#39;(x)^2)^{3/2}}.\]</p><p>The derivatives are approximated using centred three point finite differences,<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup></p><p class="math-container">\[y&#39;(x_i) \approx \frac{1}{2\Delta x}(y_{i+1} - y_{i-1})\quad\text{and}\quad y&#39;&#39;(x_i)\approx \frac{1}{\Delta x^2}(y_{i+1} - 2y_i + y_{i-1}).\]</p><p>The end-points use forward/back-differences. For the first derivative, this is</p><p class="math-container">\[y&#39;(x_1) \approx \frac{1}{2\Delta x}(-3y_{1} + 4y_2 - y_{3})\quad\text{and}\quad y&#39;(x_I) \approx \frac{1}{2\Delta x}(-y_{I-2} + 4y_{I-1} - 3y_{I}),\]</p><p>and for the second derivative, this is</p><p class="math-container">\[y&#39;&#39;(x_1) \approx \frac{1}{\Delta x^2}(y_{1} - 2y_2 + y_{3})\quad\text{and}\quad y&#39;&#39;(x_I) \approx \frac{1}{\Delta x^2}(y_{I-2} - 2y_{I-1} + y_{I}).\]</p><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.d_dx-tutorial-rankestimation"><a class="docstring-binding" href="#BlockTensorFactorization.Core.d_dx-tutorial-rankestimation"><code>BlockTensorFactorization.Core.d_dx</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">d_dx(y::AbstractVector{&lt;:Real})</code></pre><p>Approximate first derivative with finite elements.</p><p><span>$\frac{d}{dx}y[i] \approx \frac{1}{2\Delta x}(y[i+1] - y[i-1])$</span></p><p>Assumes <code>y[i] = y(x[i])</code> are samples with unit spaced inputs <code>Δx = x[i+1] - x[i] = 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L3-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.d2_dx2-tutorial-rankestimation"><a class="docstring-binding" href="#BlockTensorFactorization.Core.d2_dx2-tutorial-rankestimation"><code>BlockTensorFactorization.Core.d2_dx2</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">d2_dx2(y::AbstractVector{&lt;:Real})</code></pre><p>Approximate second derivative with finite elements.</p><p><span>$\frac{d^2}{dx^2}y[i] \approx \frac{1}{\Delta x^2}(y[i-1] - 2y[i] + y[i+1])$</span></p><p>Assumes <code>y[i] = y(x[i])</code> are samples with unit spaced inputs <code>Δx = x[i+1] - x[i] = 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L34-L42">source</a></section></details></article><h3 id="Splines"><a class="docs-heading-anchor" href="#Splines">Splines</a><a id="Splines-1"></a><a class="docs-heading-anchor-permalink" href="#Splines" title="Permalink"></a></h3><p>We calculate a third order <a href="https://en.wikipedia.org/wiki/Spline_(mathematics)">spline</a></p><p class="math-container">\[g_i(x) = a_i(x-x_i)^3+b_i(x-x_i)^2+c_i(x-x_i)+d_i,\quad x_1 \leq x \leq x_{i+1}\]</p><p>and use the coefficients to calculate the curvature of the spline</p><p class="math-container">\[k(x_i) = \frac{2b_i}{(1+c_i^2)^{3/2}}.\]</p><p>We assume the following boundary conditions;</p><ol><li><span>$g_{1}(x_{1}-\Delta x)=1$</span>, <span>$y$</span>-intercept <span>$(0,1)$</span></li><li><span>$g_{I}(x_{I}+\Delta x)=y_{I}$</span>, repeated right end-point (<span>$y_{I+1}=y_{I}$</span>)</li><li><span>$g_{I}&#39;&#39;(x_{I}+\Delta x)=0$</span>, flat right end-point,</li></ol><p>in addition to the usual continuity and smoothness assumptions of a third order spline:</p><ol><li><span>$g_{i}(x_{i})=y_{i}$</span></li><li><span>$g_{i}(x_{i+1})=g_{i+1}(x_{i+1})$</span></li><li><span>$g_{i}&#39;(x_{i+1})=g_{i+1}&#39;(x_{i+1})$</span></li><li><span>$g_{i}&#39;&#39;(x_{i+1})=g_{i+1}&#39;&#39;(x_{i+1})$</span>.</li></ol><p>We can solve for the coefficients by first solving the tri-diagonal system <span>$Mb=v$</span>, where</p><p class="math-container">\[M=\begin{bmatrix}
6 &amp; 0 &amp;  &amp; &amp; \\
1 &amp; 4 &amp; 1 &amp; &amp; \\
&amp; \ddots&amp; \ddots&amp; \ddots&amp; \\
&amp; &amp; 1 &amp; 4 &amp; 1&amp; \\
 &amp; &amp;  &amp; 0 &amp; 1
\end{bmatrix},\quad
b =\begin{bmatrix}
b_{1}  \\
b_{2}\\
\vdots \\
b_{I} \\
b_{I+1}
\end{bmatrix},\quad \text{and} \quad
v = \frac{3}{\Delta x^2}\begin{bmatrix}
1-2y_{1}+y_{2} \\
y_{3}-y_{1} \\
\vdots \\
y_{I+1}-y_{I-1} \\
0
\end{bmatrix},\]</p><p>and then calculate</p><p class="math-container">\[a_{i} = \frac{1}{3\Delta x}(b_{i+1}-b_{i})\quad \text{and}\quad c_{i}=\frac{{y_{i+1}-y_{i}}}{\Delta x}-\frac{\Delta x}{3}(b_{i+1}-2b_{i}).\]</p><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.cubic_spline_coefficients"><a class="docstring-binding" href="#BlockTensorFactorization.Core.cubic_spline_coefficients"><code>BlockTensorFactorization.Core.cubic_spline_coefficients</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cubic_spline_coefficients(y::AbstractVector{&lt;:Real}; h=1)</code></pre><p>Calculates the list of coefficients <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> for an interpolating spline of <code>y[i]=y(x[i])</code>.</p><p>The spline is defined as <span>$f(x) = g_i(x)$</span> on <span>$x[i] \leq x \leq x[i+1]$</span> where</p><p><span>$g_i(x) = a[i](x-x[i])^3 + b[i](x-x[i])^2 + c[i](x-x[i]) + d[i]$</span></p><p>Uses the following boundary conditions</p><ul><li><span>$g_1(x[1]-h) = 1$</span> (i.e. the <span>$y$</span>-intercept is <span>$(0,1)$</span> for uniform spaced <code>x=1:I</code>)</li><li><span>$g_I(x[I]+h) = y[I]$</span> (i.e. repeated right end-point)</li><li><span>$g_I&#39;&#39;(x[I]+h) = 0$</span> (i.e. flat/no-curvature one spacing after end-point)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L58-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.spline_mat"><a class="docstring-binding" href="#BlockTensorFactorization.Core.spline_mat"><code>BlockTensorFactorization.Core.spline_mat</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spline_mat(n)</code></pre><p>Creates the <code>Tridiagonal</code> matrix to solve for coefficients <code>b</code>. See <a href="#BlockTensorFactorization.Core.cubic_spline_coefficients"><code>cubic_spline_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L92-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.make_spline"><a class="docstring-binding" href="#BlockTensorFactorization.Core.make_spline"><code>BlockTensorFactorization.Core.make_spline</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_spline(y::AbstractVector{&lt;:Real}; h=1)</code></pre><p>Returns a function f(x) that is an interpolating/extrapolating spline for y, with uniform stepsize h between the x-values of the knots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L105-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline"><a class="docstring-binding" href="#BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline"><code>BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">d_dx_and_d2_dx2_spline(y::AbstractVector{&lt;:Real}; h=1)</code></pre><p>Extracts the first and second derivatives of the splines from y at the knots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L134-L138">source</a></section></details></article><h3 id="Circles"><a class="docs-heading-anchor" href="#Circles">Circles</a><a id="Circles-1"></a><a class="docs-heading-anchor-permalink" href="#Circles" title="Permalink"></a></h3><p>We compute the radius <span>$r_i$</span> of a circle passing through three neighbouring points <span>$(x_{i-1}, y_{i-1})$</span>, <span>$(x_{i}, y_{i})$</span>, and <span>$(x_{i+1}, y_{i+1})$</span>. The curvature magnitude is approximately the inverse of this radius;</p><p class="math-container">\[\lvert k(x_i)\rvert \approx \frac{1}{r_i}.\]</p><p>We assume two additional points so we can estimate the curvature at the boundary. They are</p><p class="math-container">\[(x_{0}, y_{0}) = (0, 1)\quad\text{and}\quad (x_{I+1}, y_{I+1}) = (x_{I}+\Delta x, 0).\]</p><p>To obtain a the signed curvature <span>$k(x_i)$</span>, we check if the middle point <span>$(x_{i}, y_{i})$</span> is above (negative curvature) or below (positive curvature) the line segment connecting <span>$(x_{i-1}, y_{i-1})$</span> and <span>$(x_{i+1}, y_{i+1})$</span>.</p><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.three_point_circle"><a class="docstring-binding" href="#BlockTensorFactorization.Core.three_point_circle"><code>BlockTensorFactorization.Core.three_point_circle</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">three_point_circle((a,f),(b,g),(c,h))</code></pre><p>Calculates radius <code>r</code> and center point <code>(p, q)</code> of the circle passing through the three points in the xy-plane.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">r, (p, q) = three_point_circle((1,2), (2,1), (5,2))
(r, (p, q)) == (√5, (3, 3))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L246-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.circle_curvature"><a class="docstring-binding" href="#BlockTensorFactorization.Core.circle_curvature"><code>BlockTensorFactorization.Core.circle_curvature</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">circle_curvature(y::AbstractVector{&lt;:Real}; h=1, estimate_endpoints=true)</code></pre><p>Inverse radius of a the circle passing through each 3 adjacent points on <code>y</code>, <code>(0,y[i-1])</code>, <code>(h,y[i])</code>, and <code>(2h,y[i+1])</code>.</p><p>If <code>estimate_endpoints=true</code>, assumes the function that y comes from is 1 to the left of the given values, and 0 to the right. This is typical of relative error decay as a function of rank. If <code>false</code>, pads the boundary with the adjacent curvature.</p><p>See <a href="#BlockTensorFactorization.Core.three_point_circle"><code>three_point_circle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L214-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.signed_circle_curvature"><a class="docstring-binding" href="#BlockTensorFactorization.Core.signed_circle_curvature"><code>BlockTensorFactorization.Core.signed_circle_curvature</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">signed_circle_curvature((a,f),(b,g),(c,h))</code></pre><p>Signed inverse radius of the circle passing through the 3 points in the xy-plane.</p><p>See <a href="#BlockTensorFactorization.Core.three_point_circle"><code>three_point_circle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L277-L283">source</a></section></details></article><h3 id="Two-line-Breakpoint"><a class="docs-heading-anchor" href="#Two-line-Breakpoint">Two-line Breakpoint</a><a id="Two-line-Breakpoint-1"></a><a class="docs-heading-anchor-permalink" href="#Two-line-Breakpoint" title="Permalink"></a></h3><p>This method does <strong>not</strong> approximate the curvature of a function passing through the points <span>$\{(x_i, y_i)\}$</span>, but picks the best rank based on the optimal breakpoint. The optimal breakpoint <span>$r$</span> is the breakpoint of segmented linear model that minimizes the model error.<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2" class="footnote-ref">[2]</a><span class="footnote-preview" id="fn-2"></span></sup> This means</p><p class="math-container">\[r = \argmin_{z \in \{1,\dots, R\}} \sum_{i=1}^I (f_z(x_i) - y_i)^2,\]</p><p>where</p><p class="math-container">\[f_z(x; a_z, b_z, c_z) = a_z + b_z(\min(x,z) - z) + c_z(\max(x,z) - z)\]</p><p>and the coefficients <span>$(a_z, b_z, c_z)$</span> are selected to minimize the error between the model and the data,</p><p class="math-container">\[(a_z, b_z, c_z) = \argmin_{a,b,c\in\mathbb{R}} \sum_{i=1}^I (f_z(x_i;a,b,c) - y_i)^2.\]</p><p>These coefficients have the closed form solution</p><p class="math-container">\[\begin{bmatrix}
a_{z} \\
b_{z} \\
c_{z}
\end{bmatrix} =(M^\top M)^{-1}M^\top \begin{bmatrix}
y_{1} \\
\vdots \\
y_{I}
\end{bmatrix},\quad\text{where}\quad M = \begin{bmatrix}
1 &amp; \min(x_{1},z) - z&amp;\max(x_{1},z) - z \\
\vdots &amp; \vdots &amp; \vdots\\
1 &amp; \min(x_{I},z) - z&amp;\max(x_{I},z) - z
\end{bmatrix}.\]</p><p>Geometrically, the breakpoint model is two half-infinite lines on <span>$(-\infty, z]$</span> and <span>$[z,\infty)$</span> that meet continuously at <span>$(z,a)$</span> with slopes <span>$b$</span> and <span>$c$</span> respectively.</p><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.best_breakpoint"><a class="docstring-binding" href="#BlockTensorFactorization.Core.best_breakpoint"><code>BlockTensorFactorization.Core.best_breakpoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">best_breakpoint(xs, ys; breakpoints=xs)</code></pre><p>Breakpoint <code>z in breakpoints</code> that minimizes the <a href="#BlockTensorFactorization.Core.breakpoint_error"><code>breakpoint_error</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L336-L340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.breakpoint_error"><a class="docstring-binding" href="#BlockTensorFactorization.Core.breakpoint_error"><code>BlockTensorFactorization.Core.breakpoint_error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">breakpoint_error(xs, ys, z)</code></pre><p>Squared L2 error between the best breakpoint model (with breakpoint <code>z</code>) evaluated at <code>xs</code> and the data <code>ys</code>.</p><p>See <a href="#BlockTensorFactorization.Core.breakpoint_model"><code>breakpoint_model</code></a> and <a href="#BlockTensorFactorization.Core.breakpoint_model_coefficients"><code>breakpoint_model_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L322-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.breakpoint_model"><a class="docstring-binding" href="#BlockTensorFactorization.Core.breakpoint_model"><code>BlockTensorFactorization.Core.breakpoint_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">breakpoint_model(a, b, c, z)</code></pre><p>Returns a function <code>x -&gt; a + b*(min(x, z) - z) + c*(max(x, z) - z)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L315-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.breakpoint_model_coefficients"><a class="docstring-binding" href="#BlockTensorFactorization.Core.breakpoint_model_coefficients"><code>BlockTensorFactorization.Core.breakpoint_model_coefficients</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">breakpoint_model_coefficients(xs, ys, breakpoint)</code></pre><p>Least squares fit data <span>$(x_i, y_i)$</span></p><p><span>$\min_{a,b,c} 0.5\sum_{i} (f(x_i; a,b,c) - y_i)^2$</span></p><p>with the model</p><p><span>$f(x; a,b,c) = a + b(\min(x, z) - x) + c(\max(x, z) - x)$</span></p><p>for some fixed <span>$z$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L291-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.breakpoint_curvature"><a class="docstring-binding" href="#BlockTensorFactorization.Core.breakpoint_curvature"><code>BlockTensorFactorization.Core.breakpoint_curvature</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">breakpoint_curvature(y)</code></pre><p>This is a hacked way to fit the data <code>y</code> with a breakpoint model, which can be called by <code>k = standard_curvature(...; model=:breakpoints)</code></p><p>This lets us call <code>argmax(k)</code> to get the breakpoint that minimizes the model error.</p><p>See <a href="#BlockTensorFactorization.Core.breakpoint_model_coefficients"><code>breakpoint_model_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/181fc1b9366b32ab9b55eeab3c781e50be29e100/src/Core/curvaturetools.jl#L343-L352">source</a></section></details></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>M. Abramowitz and I. A. Stegun, &quot;Handbook of mathematical functions: with formulas, graphs and mathematical tables&quot;, Unabridged, Unaltered and corr. Republ. of the 1964 ed. in Dover books on advanced mathematics. New York: Dover publ, 1972. (Table 25.2, p. 914)</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>J. E. Saylor, K. E. Sundell, and G. R. Sharman, &quot;Characterizing sediment sources by non-negative matrix factorization of detrital geochronological data,&quot; Earth and Planetary Science Letters, vol. 512, pp. 46–58, Apr. 2019, doi: <a href="https://doi.org/10.1016/j.epsl.2019.01.044">10.1016/j.epsl.2019.01.044</a>. (Section 3.2)</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../multiscale/">« Multiscale Factorization</a><a class="docs-footer-nextpage" href="../../reference/types/">Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 26 November 2025 18:42">Wednesday 26 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

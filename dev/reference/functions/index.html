<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · BlockTensorFactorization.jl</title><meta name="title" content="Functions · BlockTensorFactorization.jl"/><meta property="og:title" content="Functions · BlockTensorFactorization.jl"/><meta property="twitter:title" content="Functions · BlockTensorFactorization.jl"/><meta name="description" content="Documentation for BlockTensorFactorization.jl."/><meta property="og:description" content="Documentation for BlockTensorFactorization.jl."/><meta property="twitter:description" content="Documentation for BlockTensorFactorization.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BlockTensorFactorization.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickguide/">Quick Guide</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/decompositionmodels/">Decomposition Models</a></li><li><a class="tocitem" href="../../tutorial/constraints/">Constrained Factorization</a></li><li><a class="tocitem" href="../../tutorial/blockupdateorder/">Block Update Order</a></li><li><a class="tocitem" href="../../tutorial/iterationstats/">Iteration Stats</a></li><li><a class="tocitem" href="../../tutorial/multiscale/">Multiscale Factorization</a></li><li><a class="tocitem" href="../../tutorial/rankestimation/">Rank Estimation</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions</a></li><li><a class="tocitem" href="../">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/main/docs/src/reference/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:×₁-Tuple{AbstractArray, AbstractMatrix}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:×₁-Tuple{AbstractArray, AbstractMatrix}"><code>BlockTensorFactorization.Core.:×₁</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>1-mode product between a tensor and a matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:×₂"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:×₂"><code>BlockTensorFactorization.Core.:×₂</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>2-mode product between a tensor and a matrix. See <a href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>nmode_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:×₃"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:×₃"><code>BlockTensorFactorization.Core.:×₃</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>3-mode product between a tensor and a matrix. See <a href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>nmode_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:×₄"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:×₄"><code>BlockTensorFactorization.Core.:×₄</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>4-mode product between a tensor and a matrix. See <a href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>nmode_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:×₅"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:×₅"><code>BlockTensorFactorization.Core.:×₅</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>5-mode product between a tensor and a matrix. See <a href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>nmode_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:×₆"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:×₆"><code>BlockTensorFactorization.Core.:×₆</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>6-mode product between a tensor and a matrix. See <a href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>nmode_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:×₇"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:×₇"><code>BlockTensorFactorization.Core.:×₇</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>7-mode product between a tensor and a matrix. See <a href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>nmode_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:×₈"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:×₈"><code>BlockTensorFactorization.Core.:×₈</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>8-mode product between a tensor and a matrix. See <a href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>nmode_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:×₉"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:×₉"><code>BlockTensorFactorization.Core.:×₉</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>9-mode product between a tensor and a matrix. See <a href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>nmode_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:⋅₁"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:⋅₁"><code>BlockTensorFactorization.Core.:⋅₁</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Slice-wise dot along mode 1. See <a href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>slicewise_dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:⋅₂"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:⋅₂"><code>BlockTensorFactorization.Core.:⋅₂</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Slice-wise dot along mode 2. See <a href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>slicewise_dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:⋅₃"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:⋅₃"><code>BlockTensorFactorization.Core.:⋅₃</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Slice-wise dot along mode 3. See <a href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>slicewise_dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:⋅₄"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:⋅₄"><code>BlockTensorFactorization.Core.:⋅₄</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Slice-wise dot along mode 4. See <a href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>slicewise_dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:⋅₅"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:⋅₅"><code>BlockTensorFactorization.Core.:⋅₅</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Slice-wise dot along mode 5. See <a href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>slicewise_dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:⋅₆"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:⋅₆"><code>BlockTensorFactorization.Core.:⋅₆</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Slice-wise dot along mode 6. See <a href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>slicewise_dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:⋅₇"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:⋅₇"><code>BlockTensorFactorization.Core.:⋅₇</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Slice-wise dot along mode 7. See <a href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>slicewise_dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:⋅₈"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:⋅₈"><code>BlockTensorFactorization.Core.:⋅₈</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Slice-wise dot along mode 8. See <a href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>slicewise_dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.:⋅₉"><a class="docstring-binding" href="#BlockTensorFactorization.Core.:⋅₉"><code>BlockTensorFactorization.Core.:⋅₉</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Slice-wise dot along mode 9. See <a href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>slicewise_dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.DEFAULT_INIT"><a class="docstring-binding" href="#BlockTensorFactorization.Core.DEFAULT_INIT"><code>BlockTensorFactorization.Core.DEFAULT_INIT</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Default initialization function to use when creating a random decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.Diagonal_col_norm-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.Diagonal_col_norm-Tuple{Any}"><code>BlockTensorFactorization.Core.Diagonal_col_norm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Diagonal_col_norm(X)</code></pre><p>Calculates a diagonal matrix with entries that are the Euclidean norm of each column of <code>X</code>.</p><p>Shorthand for <code>Diagonal(norm.(eachcol(X)))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L383-L389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.IntervalConstraint-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.IntervalConstraint-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.IntervalConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Entrywise(x -&gt; clamp(x, a, b), x -&gt; a ≤ x ≤ b)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.ReLU-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.ReLU-Tuple{Any}"><code>BlockTensorFactorization.Core.ReLU</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>max(0,x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core._factorize-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core._factorize-Tuple{Any}"><code>BlockTensorFactorization.Core._factorize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_factorize(Y; kwargs...)</code></pre><p>Inner level function once keyword arguments are set</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L32-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core._gettuckerindex-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core._gettuckerindex-Tuple{Any, Any, Any}"><code>BlockTensorFactorization.Core._gettuckerindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Just computes index I in the tucker product</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.abs_randn-Tuple"><a class="docstring-binding" href="#BlockTensorFactorization.Core.abs_randn-Tuple"><code>BlockTensorFactorization.Core.abs_randn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">abs_randn(x...)</code></pre><p>Folded normal or more specifically the half-normal initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L260-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.all_recursive-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.all_recursive-Tuple{Any}"><code>BlockTensorFactorization.Core.all_recursive</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">all_recursive(x)
all_recursive(f, x)</code></pre><p>Like <code>all</code> but checks recursively on nested types like arrays of vectors, tuples of sets of arrays, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L349-L355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.array-Tuple{AbstractDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.array-Tuple{AbstractDecomposition}"><code>BlockTensorFactorization.Core.array</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array(D::AbstractDecomposition)</code></pre><p>Turns a decomposition into the full array, usually by multiplying the factors to reconstruct the full array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L60-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.best_breakpoint-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.best_breakpoint-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.best_breakpoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">best_breakpoint(xs, ys; breakpoints=xs)</code></pre><p>Breakpoint <code>z in breakpoints</code> that minimizes the <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.breakpoint_error"><code>breakpoint_error</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L336-L340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.binary!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.binary!"><code>BlockTensorFactorization.Core.binary!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Entrywise(binaryproject, x -&gt; x in (0, 1))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L432">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.breakpoint_curvature-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.breakpoint_curvature-Tuple{Any}"><code>BlockTensorFactorization.Core.breakpoint_curvature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">breakpoint_curvature(y)</code></pre><p>This is a hacked way to fit the data <code>y</code> with a breakpoint model, which can be called by <code>k = standard_curvature(...; model=:breakpoints)</code></p><p>This lets us call <code>argmax(k)</code> to get the breakpoint that minimizes the model error.</p><p>See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.breakpoint_model_coefficients"><code>breakpoint_model_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L343-L352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.breakpoint_error-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.breakpoint_error-Tuple{Any, Any, Any}"><code>BlockTensorFactorization.Core.breakpoint_error</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">breakpoint_error(xs, ys, z)</code></pre><p>Squared L2 error between the best breakpoint model (with breakpoint <code>z</code>) evaluated at <code>xs</code> and the data <code>ys</code>.</p><p>See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.breakpoint_model"><code>breakpoint_model</code></a> and <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.breakpoint_model_coefficients"><code>breakpoint_model_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L322-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.breakpoint_model-NTuple{4, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.breakpoint_model-NTuple{4, Any}"><code>BlockTensorFactorization.Core.breakpoint_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">breakpoint_model(a, b, c, z)</code></pre><p>Returns a function <code>x -&gt; a + b*(min(x, z) - z) + c*(max(x, z) - z)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L315-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.breakpoint_model_coefficients-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.breakpoint_model_coefficients-Tuple{Any, Any, Any}"><code>BlockTensorFactorization.Core.breakpoint_model_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">breakpoint_model_coefficients(xs, ys, breakpoint)</code></pre><p>Least squares fit data <span>$(x_i, y_i)$</span></p><p><span>$\min_{a,b,c} 0.5\sum_{i} (f(x_i; a,b,c) - y_i)^2$</span></p><p>with the model</p><p><span>$f(x; a,b,c) = a + b(\min(x, z) - x) + c(\max(x, z) - x)$</span></p><p>for some fixed <span>$z$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L291-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.check-Tuple{AbstractConstraint, AbstractArray}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.check-Tuple{AbstractConstraint, AbstractArray}"><code>BlockTensorFactorization.Core.check</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check(C::AbstractConstraint, A::AbstractArray)::Bool</code></pre><p>Returns <code>true</code> if <code>A</code> satisfies the constraint <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L21-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.check-Tuple{Entrywise, AbstractArray}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.check-Tuple{Entrywise, AbstractArray}"><code>BlockTensorFactorization.Core.check</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check(C::Entrywise, A::AbstractArray)::Bool</code></pre><p>Checks if <code>A</code> is entry-wise constrained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L411-L415">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.circle_curvature-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.circle_curvature-Tuple{AbstractVector{&lt;:Real}}"><code>BlockTensorFactorization.Core.circle_curvature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">circle_curvature(y::AbstractVector{&lt;:Real}; h=1, estimate_endpoints=true)</code></pre><p>Inverse radius of a the circle passing through each 3 adjacent points on <code>y</code>, <code>(0,y[i-1])</code>, <code>(h,y[i])</code>, and <code>(2h,y[i+1])</code>.</p><p>If <code>estimate_endpoints=true</code>, assumes the function that y comes from is 1 to the left of the given values, and 0 to the right. This is typical of relative error decay as a function of rank. If <code>false</code>, pads the boundary with the adjacent curvature.</p><p>See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.three_point_circle"><code>three_point_circle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L214-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.coarsen-Tuple{AbstractArray, Integer}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.coarsen-Tuple{AbstractArray, Integer}"><code>BlockTensorFactorization.Core.coarsen</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coarsen(Y::AbstractArray, scale::Integer; dims=1:ndims(Y))</code></pre><p>Coarsens or downsamples <code>Y</code> by <code>scale</code>. Only keeps every <code>scale</code> entries along the dimensions specified.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = randn(12, 12, 12)

coarsen(Y, 2) == Y[begin:2:end, begin:2:end, begin:2:end]

coarsen(Y, 4; dims=(1, 3)) == Y[begin:4:end, :, begin:4:end]

coarsen(Y, 3; dims=2) == Y[:, begin:3:end, :]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/multiscale.jl#L5-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.contractions-Tuple{AbstractDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.contractions-Tuple{AbstractDecomposition}"><code>BlockTensorFactorization.Core.contractions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contractions(D::AbstractDecomposition)</code></pre><p>A tuple of functions defining a recipe for reconstructing a full array from the factors of the decomposition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">(op1, op2) = contractions(D)
(A, B, C) = factors(D)

array(D) == op2(op1(A, B), C)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L101-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.core-Tuple{AbstractTucker}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.core-Tuple{AbstractTucker}"><code>BlockTensorFactorization.Core.core</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">core(T::AbstractTucker)</code></pre><p>The core of a Tucker-like decomposition. Same number of dimensions as the full array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L334-L338">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.cpproduct-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.cpproduct-Tuple{Any}"><code>BlockTensorFactorization.Core.cpproduct</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cpproduct((A, B, C, ...))
cpproduct(A, B, C, ...)</code></pre><p>Multiplies the inputs by treating them as matrices in a CP decomposition.</p><p><strong>Example</strong></p><p>cpproduct(A, B, C) == @einsum T[i, j, k] := A[i, r] * B[j, r] * C[k, r]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L217-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.cubic_spline_coefficients-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.cubic_spline_coefficients-Tuple{AbstractVector{&lt;:Real}}"><code>BlockTensorFactorization.Core.cubic_spline_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cubic_spline_coefficients(y::AbstractVector{&lt;:Real}; h=1)</code></pre><p>Calculates the list of coefficients <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> for an interpolating spline of <code>y[i]=y(x[i])</code>.</p><p>The spline is defined as <span>$f(x) = g_i(x)$</span> on <span>$x[i] \leq x \leq x[i+1]$</span> where</p><p><span>$g_i(x) = a[i](x-x[i])^3 + b[i](x-x[i])^2 + c[i](x-x[i]) + d[i]$</span></p><p>Uses the following boundary conditions</p><ul><li><span>$g_1(x[1]-h) = 1$</span> (i.e. the <span>$y$</span>-intercept is <span>$(0,1)$</span> for uniform spaced <code>x=1:I</code>)</li><li><span>$g_I(x[I]+h) = y[I]$</span> (i.e. repeated right end-point)</li><li><span>$g_I&#39;&#39;(x[I]+h) = 0$</span> (i.e. flat/no-curvature one spacing after end-point)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L58-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.curvature-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.curvature-Tuple{AbstractVector{&lt;:Real}}"><code>BlockTensorFactorization.Core.curvature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">curvature(y::AbstractVector{&lt;:Real}; method=:finite_differences)</code></pre><p>Approximates the signed curvature of a function given evenly spaced samples.</p><p><strong>Possible <code>method</code>s</strong></p><ul><li><code>:finite_differences</code>: Approximates first and second derivative with 3rd order finite differences. See <a href="#BlockTensorFactorization.Core.d_dx-Tuple{AbstractVector{&lt;:Real}}"><code>d_dx</code></a> and <a href="#BlockTensorFactorization.Core.d2_dx2-Tuple{AbstractVector{&lt;:Real}}"><code>d2_dx2</code></a>.</li><li><code>:splines</code>: Curvature of a third order spline. See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline"><code>d_dx_and_d2_dx2_spline</code></a>.</li><li><code>:circles</code>: Inverse radius of a circle through rolling three points. See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.circle_curvature"><code>circle_curvature</code></a>.</li><li><code>:breakpoints</code>: WARNING does not compute a value that approximates the curvature of a continuous function. Computes the inverse least-squares error of <code>f.(eachindex(y); z)</code> and <code>y</code> for all <code>z in eachindex(y)</code> where <code>f(x; z) = a + b(min(x, z) - z) + c(max(x, z) - z)</code>. Useful if <code>y</code> looks like two lines. See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.breakpoint_curvature"><code>breakpoint_curvature</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L147-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.d2_dx2-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.d2_dx2-Tuple{AbstractVector{&lt;:Real}}"><code>BlockTensorFactorization.Core.d2_dx2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d2_dx2(y::AbstractVector{&lt;:Real})</code></pre><p>Approximate second derivative with finite elements.</p><p><span>$\frac{d^2}{dx^2}y[i] \approx \frac{1}{\Delta x^2}(y[i-1] - 2y[i] + y[i+1])$</span></p><p>Assumes <code>y[i] = y(x[i])</code> are samples with unit spaced inputs <code>Δx = x[i+1] - x[i] = 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L34-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.d_dx-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.d_dx-Tuple{AbstractVector{&lt;:Real}}"><code>BlockTensorFactorization.Core.d_dx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d_dx(y::AbstractVector{&lt;:Real})</code></pre><p>Approximate first derivative with finite elements.</p><p><span>$\frac{d}{dx}y[i] \approx \frac{1}{2\Delta x}(y[i+1] - y[i-1])$</span></p><p>Assumes <code>y[i] = y(x[i])</code> are samples with unit spaced inputs <code>Δx = x[i+1] - x[i] = 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L3-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline-Tuple{AbstractVector{&lt;:Real}}"><code>BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d_dx_and_d2_dx2_spline(y::AbstractVector{&lt;:Real}; h=1)</code></pre><p>Extracts the first and second derivatives of the splines from y at the knots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L134-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.default_kwargs-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.default_kwargs-Tuple{Any}"><code>BlockTensorFactorization.Core.default_kwargs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">default_kwargs(Y; kwargs...)</code></pre><p>Handles all keywords and options, and sets defaults if not provided.</p><p><strong>Keywords &amp; Defaults</strong></p><p><strong>Initialization</strong></p><ul><li><code>decomposition</code>: <code>nothing</code>. Can provide a custom initialized AbstractDecomposition. Note this exact decomposition is mutated.</li><li><code>model</code>: <code>Tucker1</code>, but overridden by the type of AbstractDecomposition if given <code>decomposition</code></li><li><code>rank</code>: <code>nothing</code>, but overridden by the rank of AbstractDecomposition if given <code>decomposition</code>. Automatically calls <code>rank_detect_factorize</code> if both <code>rank</code> &amp; <code>decomposition</code> are not provided.</li><li><code>init</code>: <code>abs_randn</code> for nonnegative inputs <code>Y</code>, <code>randn</code> otherwise</li><li><code>constrain_init</code>: <code>true</code>. Ensures the initialization satisfies all given <code>constraints</code>. Defaults to <code>false</code> if given <code>decomposition</code></li><li><code>freeze</code>: the default frozen factors of the <code>model</code></li><li><code>continuous_dims</code>: <code>missing</code>. Dimensions of <code>Y</code> that come from discretizations of continuous data. If provided, <code>multiscale_factorize</code> is called and can speed up factorization. If <code>continuous_dims==nothing</code>, factorization will only happen at one scale. In the future, if <code>continuous_dims==missing</code>,<code>factorize</code> may guess if there are continuous dimensions.</li></ul><p><strong>Updates</strong></p><ul><li><code>objective</code>: <code>L2()</code>. Objective to minimize</li><li><code>norm</code>: <code>l2norm</code>. Norm to use for statistics, can be unrelated to the objective</li><li><code>random_order</code>: <code>false</code>. Perform the updates in a random order each iteration, Overrides to <code>true</code> when <code>recursive_random_order=true</code></li><li><code>group_updates_by_factor</code>: <code>false</code>. Groups updates on the same factor together. Overrides to <code>true</code> when <code>random_order=true</code>. Useful when randomizing order of updates but you want to keep matching momentum-gradientstep-constraint together</li><li><code>recursive_random_order</code>: <code>false</code>. Performs inner blocked updates (grouped updates) in a random order (recursively) each iteration. Note the outer most list of updates can be performed in order if <code>random_order=false</code></li><li><code>do_subblock_updates</code>: <code>false</code>. Performs gradient descent on subblocks within a factor separately. May result in smaller Lipschitz constants and hence larger step sizes being used.</li></ul><p><strong>Momentum</strong></p><ul><li><code>momentum</code>: <code>true</code></li><li><code>δ</code>: <code>0.9999</code>. Amount of momentum, between [0,1)</li><li><code>previous_iterates</code>: <code>1</code>. Number of pervious iterates to save and use between iterations</li></ul><p><strong>Constraints</strong></p><ul><li><code>constraints</code>: <code>nothing</code>. Can be a list of ConstraintUpdate, or just one</li><li><code>final_constraints</code>: <code>nothing</code>. Constraints to apply after the final iteration. Will apply <code>constraints</code> if <code>constrain_output</code> is <code>true</code> and none are given</li><li><code>constrain_output</code>: <code>false</code>. Apply the <code>final_constraints</code>, will override to <code>true</code> if <code>final_constraints</code> are given</li></ul><p><strong>Stats</strong></p><ul><li><code>stats</code>: <code>[Iteration, ObjectiveValue, GradientNorm]</code> or in the case of nonnegative <code>Y</code>, <code>GradientNNCone</code> in place of <code>GradientNorm</code></li><li><code>converged</code>: <code>GradientNorm</code> or in the case of nonnegative <code>Y</code>, <code>GradientNNCone</code>. What stat(s) to use for convergence. Will converge is any one of the provided stats is below their respective tolerance</li><li><code>tolerance</code>: <code>1</code>. A list the same length as <code>converged</code></li><li><code>maxiter</code>: <code>1000</code>. Additional stopping criterion if the number of iterations exceeds this number</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L102-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.eachfactorindex-Tuple{AbstractDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.eachfactorindex-Tuple{AbstractDecomposition}"><code>BlockTensorFactorization.Core.eachfactorindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eachfactorindex(D::AbstractDecomposition)</code></pre><p>An iterable to index the factors of <code>D</code>; not necessarily 1:ndims(D). Does not include non-data factors like the core of a <code>CPDecomposition</code>.</p><p>For example, <code>eachfactorindex(D::Tucker) == 0:ndims(D)</code> since <code>core(D)</code> is the zeroth factor. <code>eachfactorindex(D::CPDecomposition) == 1:ndims(D)</code>. <code>core(D)</code> exists, but it is frozen as the identity tensor. And <code>eachfactorindex(D::Tucker1) == 0:1</code> representing the core and matrix factor of <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L87-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.eachfibre-Tuple{AbstractArray}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.eachfibre-Tuple{AbstractArray}"><code>BlockTensorFactorization.Core.eachfibre</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eachfibre(A::AbstractArray; n::Integer, kwargs...)</code></pre><p>Creates views of <code>A</code> that are that <code>n</code>-fibres of <code>A</code>.</p><p>Shorthand for <code>eachslice(A; dims=(1,...,n-1,n+1,...,ndims(A)))</code>.</p><p>See <code>eachslice</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L117-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.eachrank1term-Tuple{AbstractTucker}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.eachrank1term-Tuple{AbstractTucker}"><code>BlockTensorFactorization.Core.eachrank1term</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eachrank1term(T::AbstractTucker)</code></pre><p>Creates a generator for each rank 1 term of a Tucker decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L358-L362">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.eachrank1term-Tuple{CPDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.eachrank1term-Tuple{CPDecomposition}"><code>BlockTensorFactorization.Core.eachrank1term</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eachrank1term(T::CPDecomposition)</code></pre><p>The (CP) rank-1 tensors <code>Tr[i1, ..., iN] = A1[i1, r] * … * AN[iN, r]</code>  for each <code>r = 1, …, rankof(T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L453-L457">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.eachrank1term-Tuple{Tucker1}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.eachrank1term-Tuple{Tucker1}"><code>BlockTensorFactorization.Core.eachrank1term</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eachrank1term(T::Tucker1)</code></pre><p>The (Tucker-1) rank-1 tensors <code>Tr[i1, ..., iN] = A[i1, r] * B[r, i2, ..., iN]</code> for each <code>r = 1, …, rankof(T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L365-L369">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.expand_decomposition_constraints-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.expand_decomposition_constraints-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.expand_decomposition_constraints</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expand_decomposition_constraints(Y, kwargs)</code></pre><p>Use the same initialization as <a href="#BlockTensorFactorization.Core.factorize-Tuple{Any}"><code>factorize</code></a> to get the expanded set of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/multiscale.jl#L224-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.factor-Tuple{AbstractDecomposition, Integer}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.factor-Tuple{AbstractDecomposition, Integer}"><code>BlockTensorFactorization.Core.factor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">factor(D::AbstractDecomposition, n::Integer)</code></pre><p>The <code>n</code>th factor of <code>D</code>.</p><p>Use <a href="#BlockTensorFactorization.Core.factors-Tuple{AbstractDecomposition}"><code>factors</code></a> to get all the factors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L78-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.factorize-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.factorize-Tuple{Any}"><code>BlockTensorFactorization.Core.factorize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">factorize(Y; rank=nothing, model=Tucker1, kwargs...)</code></pre><p>Factorizes <code>Y</code> according to the decomposition <code>model</code>.</p><p>See <a href="#BlockTensorFactorization.Core.default_kwargs-Tuple{Any}"><code>default_kwargs</code></a> for the default keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.factors-Tuple{AbstractDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.factors-Tuple{AbstractDecomposition}"><code>BlockTensorFactorization.Core.factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">factors(D::AbstractDecomposition)</code></pre><p>A tuple of arrays representing the decomposition of <code>D</code>.</p><p>Use <a href="#BlockTensorFactorization.Core.factor-Tuple{AbstractDecomposition, Integer}"><code>factor</code></a> to get just the <code>n</code>th factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L69-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.false_tuple-Tuple{Integer}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.false_tuple-Tuple{Integer}"><code>BlockTensorFactorization.Core.false_tuple</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">false_tuple(n::Integer)</code></pre><p>Makes a Tuple of length n filled with <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L156-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.finalconstrain!-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.finalconstrain!-Tuple{Any}"><code>BlockTensorFactorization.Core.finalconstrain!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">finalconstrain!(decomposition; constraints, final_constraints, kwargs...)</code></pre><p>Applies final_constraints (or if its nothing, applies constraints) to the decomposition.</p><p>Any RescaleUpdate are applied (the factor is scaled), but the rescaling of other factors is skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L248-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.frozen-Tuple{AbstractDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.frozen-Tuple{AbstractDecomposition}"><code>BlockTensorFactorization.Core.frozen</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">frozen(D::AbstractDecomposition)</code></pre><p>A tuple of <code>Bool</code>s the same length as <code>factors(D)</code> showing which factors are &quot;frozen&quot; in the sense that a block decent algorithm should skip these factors when decomposing a tensor.</p><p>See <a href="#BlockTensorFactorization.Core.isfrozen-Tuple{AbstractDecomposition, Integer}"><code>isfrozen</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L118-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.geomean-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.geomean-Tuple{Any}"><code>BlockTensorFactorization.Core.geomean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">geomean(v)
geomean(v...)</code></pre><p>Geometric mean of a collection: <code>prod(v)^(1/length(v))</code>.</p><p>If <code>prod(v)</code> is detected to be <code>0</code> or <code>Inf</code>, the safer (but slower) implementation <code>exp(mean(log.(v)))</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L302-L309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.getnotindex"><a class="docstring-binding" href="#BlockTensorFactorization.Core.getnotindex"><code>BlockTensorFactorization.Core.getnotindex</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getnotindex(A, i::Int; view=false)
getnotindex(A, I; view=false)</code></pre><p>Like <code>getindex</code> but returns the compliment to the index or indices requested.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L114-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.group_by_factor-Tuple{BlockedUpdate}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.group_by_factor-Tuple{BlockedUpdate}"><code>BlockTensorFactorization.Core.group_by_factor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">group_by_factor(blockedupdate::BlockedUpdate)</code></pre><p>Groups updates according to the factor they operate on.</p><p>If blockedupdate contains other <code>BlockedUpdate</code>s, the inner updates are grouped when they all operate on the same factor.</p><p>Updates which do not have an assigned factor are grouped together.</p><p>The order which these groups appear in the output follows the same order as the first appearence of each unique factor that is operated on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/blockupdates.jl#L845-L857">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.identity_tensor-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.identity_tensor-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.identity_tensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identity_tensor(I, ndims)
identity_tensor(T, I, ndims)</code></pre><p>Creates a SuperDiagonal array of ones with size I × ... × I of order <code>ndims</code>.</p><p>Can provide a type <code>T</code> for the identity tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L60-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.identityslice-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.identityslice-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>BlockTensorFactorization.Core.identityslice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identityslice(x::AbstractArray{T, N})</code></pre><p>Useful for returning an iterable with a single iterate x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L247-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.initialize-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.initialize-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.initialize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize(Y, kwargs)</code></pre><p>Main initialization function for <code>factorize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L60-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.initialize_continuous_dims-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.initialize_continuous_dims-Tuple{Any}"><code>BlockTensorFactorization.Core.initialize_continuous_dims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_continuous_dims(Y; kwargs...)</code></pre><p>Lists dimensions of Y that represent a discretization of a continuous function.</p><p>Defaults to all of them: <code>continuous_dims = 1:ndims(Y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/multiscale.jl#L483-L489">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.initialize_decomposition-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.initialize_decomposition-Tuple{Any}"><code>BlockTensorFactorization.Core.initialize_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_decomposition(Y; decomposition, model, rank, kwargs...)</code></pre><p>The decomposition model Y will be factored into</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L275-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.initialize_parameters-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.initialize_parameters-Tuple{Any, Any, Any}"><code>BlockTensorFactorization.Core.initialize_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_parameters(decomposition, Y, previous; momentum::Bool, random_order, recursive_random_order, kwargs...)</code></pre><p>update parameters needed for the update</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L395-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.initialize_previous-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.initialize_previous-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.initialize_previous</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_previous(decomposition, Y; previous_iterates::Integer, kwargs...)</code></pre><p>Keep track of one or more previous iterates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L373-L377">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.initialize_scales-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.initialize_scales-Tuple{Any}"><code>BlockTensorFactorization.Core.initialize_scales</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_scales(Y, kwargs)</code></pre><p>Initializes the plan for factorizing at progressively finer scales.</p><p>The list of scales should be ordered from largest (coarse) to smallest (fine) and end with 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/multiscale.jl#L448-L454">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.initialize_stats-NTuple{4, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.initialize_stats-NTuple{4, Any}"><code>BlockTensorFactorization.Core.initialize_stats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_stats(decomposition, Y, previous, parameters; stats, kwargs...)</code></pre><p>The stats that will be saved every iteration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L356-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.interlace-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.interlace-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.interlace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interlace(u, v)</code></pre><p>Takes two iterables, u and v, and alternates elements from u and v into a vector. If u and v are not the same length, extra elements are put on the end of the vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L284-L289">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.interpolate-Tuple{AbstractArray, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.interpolate-Tuple{AbstractArray, Any}"><code>BlockTensorFactorization.Core.interpolate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate(Y, scale; dims=1:ndims(Y), degree=0, kwargs...)</code></pre><p>Interpolates Y to a larger array with repeated values.</p><p><strong>Keywords</strong></p><p><code>scale</code>. How much to scale up the size of <code>Y</code>. A dimension with size <code>k</code> will be scaled to <code>scale*k - (scale - 1) = scale*(k-1) + 1</code></p><p><code>dims</code>:<code>1:ndims(Y)</code>. Which dimensions to interpolate.</p><p><code>degree</code>:<code>0</code>. What degree of interpolation to use. <code>0</code> is constant interpolation, <code>1</code> is linear.</p><p>Like the opposite of <a href="#BlockTensorFactorization.Core.coarsen-Tuple{AbstractArray, Integer}"><code>coarsen</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; Y = collect(reshape(1:6, 2, 3))
2×3 Matrix{Int64}:
 1  3  5
 2  4  6

julia&gt; interpolate(Y, 2)
3×5 Matrix{Int64}:
 1  1  3  3  5
 1  1  3  3  5
 2  2  4  4  6

julia&gt; interpolate(Y, 3; dims=2)
2×7 Matrix{Int64}:
 1  1  1  3  3  3  5
 2  2  2  4  4  4  6

julia&gt; interpolate(Y, 1) == Y
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/multiscale.jl#L27-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.isfrozen-Tuple{AbstractDecomposition, Integer}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.isfrozen-Tuple{AbstractDecomposition, Integer}"><code>BlockTensorFactorization.Core.isfrozen</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isfrozen(D::AbstractDecomposition, n::Integer)</code></pre><p><code>True</code> if the <code>n</code>th factor of <code>D</code> is frozen. See <a href="#BlockTensorFactorization.Core.frozen-Tuple{AbstractDecomposition}"><code>frozen</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L128-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.isnonnegative-Tuple{AbstractArray{&lt;:Real}}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.isnonnegative-Tuple{AbstractArray{&lt;:Real}}"><code>BlockTensorFactorization.Core.isnonnegative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isnonnegative(X::AbstractArray{&lt;:Real})
isnonnegative(x::Real)</code></pre><p>Checks if all entries of X are bigger or equal to zero. Will be a standard function in Base but using this for now: https://github.com/JuliaLang/julia/pull/53677</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L267-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.isnonnegative_sumtoone-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.isnonnegative_sumtoone-Tuple{Any}"><code>BlockTensorFactorization.Core.isnonnegative_sumtoone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isnonnegative_sumtoone(x)</code></pre><p>Short for <code>all(isnonnegative, x) &amp;&amp; sum(x) ≈ 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L203-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.khatrirao-Tuple{AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.khatrirao-Tuple{AbstractMatrix, AbstractMatrix}"><code>BlockTensorFactorization.Core.khatrirao</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">khatrirao(A::AbstractMatrix, B::AbstractMatrix)
A ⊙ B</code></pre><p>Khatri-Rao product of two matrices. A ⊙ B can be typed with <code>\odot</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L230-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1normalize!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1normalize!"><code>BlockTensorFactorization.Core.l1normalize!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1normalize! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l1norm, l1project!; whats_normalized=identityslice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1normalize_12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1normalize_12slices!"><code>BlockTensorFactorization.Core.l1normalize_12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1normalize_12slices! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l1norm, l1project!; whats_normalized=each12slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1normalize_1slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1normalize_1slices!"><code>BlockTensorFactorization.Core.l1normalize_1slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1normalize_1slices! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l1norm, l1project!; whats_normalized=each1slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1normalize_cols!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1normalize_cols!"><code>BlockTensorFactorization.Core.l1normalize_cols!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1normalize_cols! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l1norm, l1project!; whats_normalized=eachcol)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1normalize_rows!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1normalize_rows!"><code>BlockTensorFactorization.Core.l1normalize_rows!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1normalize_rows! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l1norm, l1project!; whats_normalized=eachrow)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1scale!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1scale!"><code>BlockTensorFactorization.Core.l1scale!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1scale! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l1norm; whats_normalized=identityslice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1scale_12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1scale_12slices!"><code>BlockTensorFactorization.Core.l1scale_12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1scale_12slices! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l1norm; whats_normalized=each12slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1scale_1slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1scale_1slices!"><code>BlockTensorFactorization.Core.l1scale_1slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1scale_1slices! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l1norm; whats_normalized=each1slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1scale_average12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1scale_average12slices!"><code>BlockTensorFactorization.Core.l1scale_average12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1scale_average12slices! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l1norm; whats_normalized=each1slice, scale=size2)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1scale_cols!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1scale_cols!"><code>BlockTensorFactorization.Core.l1scale_cols!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1scale_cols! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l1norm; whats_normalized=eachcol)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l1scale_rows!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l1scale_rows!"><code>BlockTensorFactorization.Core.l1scale_rows!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l1scale_rows! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l1norm; whats_normalized=eachrow)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2normalize!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2normalize!"><code>BlockTensorFactorization.Core.l2normalize!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2normalize! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l2norm, l2project!; whats_normalized=identityslice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2normalize_12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2normalize_12slices!"><code>BlockTensorFactorization.Core.l2normalize_12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2normalize_12slices! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l2norm, l2project!; whats_normalized=each12slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2normalize_1slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2normalize_1slices!"><code>BlockTensorFactorization.Core.l2normalize_1slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2normalize_1slices! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l2norm, l2project!; whats_normalized=each1slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2normalize_cols!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2normalize_cols!"><code>BlockTensorFactorization.Core.l2normalize_cols!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2normalize_cols! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l2norm, l2project!; whats_normalized=eachcol)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2normalize_rows!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2normalize_rows!"><code>BlockTensorFactorization.Core.l2normalize_rows!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2normalize_rows! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(l2norm, l2project!; whats_normalized=eachrow)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2scale!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2scale!"><code>BlockTensorFactorization.Core.l2scale!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2scale! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l2norm; whats_normalized=identityslice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2scale_12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2scale_12slices!"><code>BlockTensorFactorization.Core.l2scale_12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2scale_12slices! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l2norm; whats_normalized=each12slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2scale_1slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2scale_1slices!"><code>BlockTensorFactorization.Core.l2scale_1slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2scale_1slices! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l2norm; whats_normalized=each1slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2scale_average12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2scale_average12slices!"><code>BlockTensorFactorization.Core.l2scale_average12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2scale_average12slices! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l2norm; whats_normalized=each1slice, scale=size2)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2scale_cols!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2scale_cols!"><code>BlockTensorFactorization.Core.l2scale_cols!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2scale_cols! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l2norm; whats_normalized=eachcol)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.l2scale_rows!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.l2scale_rows!"><code>BlockTensorFactorization.Core.l2scale_rows!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">l2scale_rows! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(l2norm; whats_normalized=eachrow)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftynorm-Tuple{AbstractArray}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftynorm-Tuple{AbstractArray}"><code>BlockTensorFactorization.Core.linftynorm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linftynorm(x::AbstractArray)</code></pre><p>Calculates ‖x‖_∞.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L210-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftynormalize!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftynormalize!"><code>BlockTensorFactorization.Core.linftynormalize!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftynormalize! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(linftynorm, linftyproject!; whats_normalized=identityslice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftynormalize_12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftynormalize_12slices!"><code>BlockTensorFactorization.Core.linftynormalize_12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftynormalize_12slices! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(linftynorm, linftyproject!; whats_normalized=each12slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftynormalize_1slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftynormalize_1slices!"><code>BlockTensorFactorization.Core.linftynormalize_1slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftynormalize_1slices! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(linftynorm, linftyproject!; whats_normalized=each1slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftynormalize_cols!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftynormalize_cols!"><code>BlockTensorFactorization.Core.linftynormalize_cols!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftynormalize_cols! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(linftynorm, linftyproject!; whats_normalized=eachcol)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftynormalize_rows!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftynormalize_rows!"><code>BlockTensorFactorization.Core.linftynormalize_rows!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftynormalize_rows! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(linftynorm, linftyproject!; whats_normalized=eachrow)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftyproject!-Tuple{AbstractArray}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftyproject!-Tuple{AbstractArray}"><code>BlockTensorFactorization.Core.linftyproject!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linftyproject!(x::AbstractArray)</code></pre><p>Euclidean projection onto the unit L∞-ball.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L217-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftyscale!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftyscale!"><code>BlockTensorFactorization.Core.linftyscale!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftyscale! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(linftynorm; whats_normalized=identityslice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftyscale_12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftyscale_12slices!"><code>BlockTensorFactorization.Core.linftyscale_12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftyscale_12slices! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(linftynorm; whats_normalized=each12slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftyscale_1slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftyscale_1slices!"><code>BlockTensorFactorization.Core.linftyscale_1slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftyscale_1slices! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(linftynorm; whats_normalized=each1slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftyscale_average12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftyscale_average12slices!"><code>BlockTensorFactorization.Core.linftyscale_average12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftyscale_average12slices! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(linftynorm; whats_normalized=each1slice, scale=size2)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftyscale_cols!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftyscale_cols!"><code>BlockTensorFactorization.Core.linftyscale_cols!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftyscale_cols! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(linftynorm; whats_normalized=eachcol)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.linftyscale_rows!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.linftyscale_rows!"><code>BlockTensorFactorization.Core.linftyscale_rows!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linftyscale_rows! &lt;: ScaledNormalization</code></pre><p>Alias for</p><p><code>ScaledNormalization(linftynorm; whats_normalized=eachrow)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ScaledNormalization"><code>ScaledNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.make_spline-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.make_spline-Tuple{AbstractVector{&lt;:Real}}"><code>BlockTensorFactorization.Core.make_spline</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_spline(y::AbstractVector{&lt;:Real}; h=1)</code></pre><p>Returns a function f(x) that is an interpolating/extrapolating spline for y, with uniform stepsize h between the x-values of the knots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L105-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.make_update!-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.make_update!-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.make_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_update!(decomposition, Y; momentum, constraints, constrain_init, group_updates_by_factor, do_subblock_updates, kwargs...)</code></pre><p>What one iteration of the algorithm looks like. One iteration is likely a full cycle through each block or factor of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L294-L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.mat-Tuple{AbstractArray, Integer}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.mat-Tuple{AbstractArray, Integer}"><code>BlockTensorFactorization.Core.mat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat(A::AbstractArray, n::Integer)</code></pre><p>Matricize along the nth mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L142-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.match_cols!-Tuple{AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.match_cols!-Tuple{AbstractMatrix, AbstractMatrix}"><code>BlockTensorFactorization.Core.match_cols!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">match_cols!(X::AbstractMatrix, Y::AbstractMatrix; kwargs...)</code></pre><p><code>match_slices!</code> along the second dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factormatching.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.match_factors!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractDecomposition"><a class="docstring-binding" href="#BlockTensorFactorization.Core.match_factors!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractDecomposition"><code>BlockTensorFactorization.Core.match_factors!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">match_factors!(X::T, Y::T; dist=L2) where {T &lt;: AbstractDecomposition}</code></pre><p>Reorders the rank-1 terms of X to best match the slices of Y.</p><p>This is currently implemented for Tucker1 and CPDecomposition.</p><p>See <a href="#BlockTensorFactorization.Core.match_slices!-Tuple{AbstractArray, AbstractArray}"><code>match_slices!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factormatching.jl#L74-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.match_rows!-Tuple{AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.match_rows!-Tuple{AbstractMatrix, AbstractMatrix}"><code>BlockTensorFactorization.Core.match_rows!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">match_rows!(X::AbstractMatrix, Y::AbstractMatrix; kwargs...)</code></pre><p><code>match_slices!</code> along the first dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factormatching.jl#L60-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.match_slices!-Tuple{AbstractArray, AbstractArray}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.match_slices!-Tuple{AbstractArray, AbstractArray}"><code>BlockTensorFactorization.Core.match_slices!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">match_slices!(X, Y; dims, dist=L2)</code></pre><p>Reorders the order-<code>dims</code> slices of X to best match the slices of Y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factormatching.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.matrix_factor-Tuple{AbstractTucker, Integer}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.matrix_factor-Tuple{AbstractTucker, Integer}"><code>BlockTensorFactorization.Core.matrix_factor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">matrix_factor(T::AbstractTucker, n::Integer)</code></pre><p>The <code>n</code>th matrix factor. See <a href="#BlockTensorFactorization.Core.matrix_factors-Tuple{AbstractTucker}"><code>matrix_factors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L348-L352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.matrix_factors-Tuple{AbstractTucker}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.matrix_factors-Tuple{AbstractTucker}"><code>BlockTensorFactorization.Core.matrix_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">matrix_factors(T::AbstractTucker)</code></pre><p>Tuple of the non-core factors of <code>T</code>. See <a href="#BlockTensorFactorization.Core.matrix_factor-Tuple{AbstractTucker, Integer}"><code>matrix_factor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L341-L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.max_possible_rank-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.max_possible_rank-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.max_possible_rank</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">max_possible_rank(Y, model)</code></pre><p>Returns the maximum rank possible <code>Y</code> could have under the <code>model</code>.</p><p>For matrices <code>I × J</code> this is <code>1:min(I, J)</code>. This is can be extended to tensors for different type of decompositions.</p><p>Tucker-1 rank is <code>≤ min(I, prod(J1,...,JN))</code> for tensors <code>I × J1 × … × JN</code>.</p><p>The CP-rank is <code>≤ minimum_{n} (prod(I1,...,IN) / In)</code> for tensors <code>I1 × … × IN</code> in general. Although some shapes have have tighter upper bounds. For example, <code>2 × I × I</code> tensors over ℝ have a maximum rank of <code>floor(3I/2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/rankdetection.jl#L76-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.mtt-Tuple{AbstractMatrix, AbstractArray}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.mtt-Tuple{AbstractMatrix, AbstractArray}"><code>BlockTensorFactorization.Core.mtt</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mtt(A::AbstractMatrix, B::AbstractArray)</code></pre><p>Matrix Times Tensor. Entry-wise,</p><p><code>mtt(A, B)[i1, i2, …, iN] = ∑_r A[i1, r] * B[r, i2, …, iN]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L44-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.multifoldl-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.multifoldl-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.multifoldl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">multifoldl(ops, args)</code></pre><p>Like <code>foldl</code>, but with a different folding operation between each argument.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; multifoldl((+,*,-), (2,3,4,5))
15

julia&gt; ((2 + 3) * 4) - 5
15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L325-L339">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.multiscale_factorize-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.multiscale_factorize-Tuple{Any}"><code>BlockTensorFactorization.Core.multiscale_factorize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">multiscale_factorize(Y; continuous_dims=1:ndims(Y), rank=1, model=Tucker1, kwargs...)</code></pre><p>Like <a href="#BlockTensorFactorization.Core.factorize-Tuple{Any}"><code>factorize</code></a> but uses progressively finer sub-grids of <code>Y</code> to speed up convergence. This is only effective when the dimensions given by <code>dims</code> come from discretizations of continuous data.</p><p>For example, if <code>Y</code> has 3 dimensions where <code>Y[i, j, k]</code> are samples from a continuous 2D function f<em>i(x</em>j, y_k) on a grid, use</p><p><code>multiscale_factorize(Y; continuous_dims=(2,3))</code></p><p>since second and third dimensions are continuous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/multiscale.jl#L137-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.nfactors-Tuple{AbstractDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.nfactors-Tuple{AbstractDecomposition}"><code>BlockTensorFactorization.Core.nfactors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nfactors(D::AbstractDecomposition)</code></pre><p>Returns the number of factors/blocks in a decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L53-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>BlockTensorFactorization.Core.nmode_product</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nmode_product(A::AbstractArray, B::AbstractMatrix, n::Integer)</code></pre><p>Contracts the <code>n</code>th mode of <code>A</code> with the first mode of <code>B</code>. Equivalent to <code>A</code> ×ₙ <code>B</code> where</p><p><code>(A ×ₙ B)[i₁, …, i_N] = ∑ⱼ A[i₁, …, iₙ₋₁, j, iₙ₊₁, …, i_N] B[iₙ, j]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L6-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractVector, Integer}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractVector, Integer}"><code>BlockTensorFactorization.Core.nmode_product</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nmode_product(A::AbstractArray, b::AbstractVector, n::Integer)</code></pre><p>Contracts the <code>n</code>th mode of <code>A</code> with <code>b</code>. Equivalent to <code>A</code> ×ₙ <code>b</code> where</p><p><code>(A ×ₙ b)[i₁, …, iₙ₋₁, iₙ₊₁, …, i_N] = ∑_iₙ A[i₁, …, i_N] b[iₙ]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L23-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.nmp"><a class="docstring-binding" href="#BlockTensorFactorization.Core.nmp"><code>BlockTensorFactorization.Core.nmp</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Shorthand for <a href="#BlockTensorFactorization.Core.nmode_product-Tuple{AbstractArray, AbstractMatrix, Integer}"><code>nmode_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.nonnegative!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.nonnegative!"><code>BlockTensorFactorization.Core.nonnegative!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Entrywise(ReLU, isnonnegative)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L418">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.norm2-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.norm2-Tuple{Any}"><code>BlockTensorFactorization.Core.norm2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm2(x)</code></pre><p>L2 norm squared, the sum of squares of the entries of x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L277-L281">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.outer_product-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.outer_product-Tuple{Any}"><code>BlockTensorFactorization.Core.outer_product</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">outer_product(vectors)
outer_product(vectors...)</code></pre><p>Outer product of a collection of vectors.</p><p>For example,</p><p><code>outer_product(u, v) == u * v&#39;</code></p><p>and</p><p><code>outer_product(u, v, w)[i, j, k] == u[i] * v[j] * w[k]</code>.</p><p>Returned array will have same number dimensions as the length of the collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L198-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.parse_constraints-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.parse_constraints-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.parse_constraints</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_constraints(constraints, decomposition; kwargs...)</code></pre><p>Parses the constraints to make sure we have a valid list of ConstraintUpdate.</p><p>If only one AbstractConstraint is given, assume we want this constraint to apply to every factor in the decomposition, and make a ConstraintUpdate for each factor.</p><p>If we are given a list of AbstractConstraint, assume we want them to apply to each factor of the decomposition in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L220-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.postprocess!-NTuple{8, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.postprocess!-NTuple{8, Any}"><code>BlockTensorFactorization.Core.postprocess!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">postprocess!(decomposition, Y, previous, parameters, stats_data, updateparameters!, getstats, kwargs)</code></pre><p>Any post algorithm processing that needs to be done in <code>factorize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/factorize.jl#L85-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.proj_one_hot!-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.proj_one_hot!-Tuple{Any}"><code>BlockTensorFactorization.Core.proj_one_hot!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">proj_one_hot!(x)</code></pre><p>Mutating version of <a href="#BlockTensorFactorization.Core.proj_one_hot-Tuple{Any}"><code>proj_one_hot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L232-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.proj_one_hot-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.proj_one_hot-Tuple{Any}"><code>BlockTensorFactorization.Core.proj_one_hot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">proj_one_hot(x)</code></pre><p>Projects an array x to the closest one hot array: an array with all 0&#39;s except for a single 1. Does not mutate; see <a href="#BlockTensorFactorization.Core.proj_one_hot!-Tuple{Any}"><code>proj_one_hot!</code></a> for a mutating version.</p><p>This is not a unique projection if there are multiple largest entries. In this case, will pick one of the largest entries to be 1 and set the rest to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L216-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.projsplx!-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.projsplx!-Tuple{Any}"><code>BlockTensorFactorization.Core.projsplx!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">projsplx!(y; sum=one(eltype(y)))</code></pre><p>Projects (in Euclidean distance) the array y into the simplex.</p><p>See <code>projsplx</code> for a non-mutating version.</p><p>[1] Yunmei Chen and Xiaojing Ye, &quot;Projection Onto A Simplex&quot;, 2011</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L163-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.projsplx-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.projsplx-Tuple{Any}"><code>BlockTensorFactorization.Core.projsplx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">projsplx(y; sum=one(eltype(y)))</code></pre><p>Non-mutating version of <code>projsplx!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L206-L210">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.rank_detect_factorize-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.rank_detect_factorize-Tuple{Any}"><code>BlockTensorFactorization.Core.rank_detect_factorize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rank_detect_factorize(Y; kwargs...)</code></pre><p>Wraps <code>factorize()</code> with rank detection.</p><p>Selects the rank that maximizes the standard curvature of the Relative Error (as a function of rank).</p><p><strong>Keywords</strong></p><ul><li><code>online_rank_estimation</code>: <code>false</code>. Set to <code>true</code> to stop testing larger ranks after the first peak in curvature</li><li><code>curvature_method</code>: <code>:splines</code>. Can also pick <code>:finite_differences</code> (faster but less accurate) or <code>circles</code> (fastest and smallest memory but more sensitive to results from <code>factorize</code>). Set to <code>:breakpoints</code> to pick the rank <code>R</code> that minimizes least-squares error in the model <code>f(r) = a + b(min(r, R) - R) + c(max(r, R) - R)</code> and the errors.</li><li><code>model</code>: <code>Tucker1</code>. Only rank detection with <code>Tucker1</code> and <code>CPDecomposition</code> is currently implemented</li><li><code>max_rank</code>: <code>max_possible_rank(Y, model)</code>. Test ranks from <code>1</code> up to <code>max_rank</code>. Defaults to largest possible rank under the model</li><li><code>rank</code>: <code>nothing</code>. If a rank is passed, rank detection is ignored and <code>factorize(Y; kwargs...)</code> is called</li></ul><p>Any other keywords from <a href="#BlockTensorFactorization.Core.factorize-Tuple{Any}"><code>factorize</code></a>, full list given by <a href="#BlockTensorFactorization.Core.default_kwargs-Tuple{Any}"><code>default_kwargs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/rankdetection.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.rankof-Tuple{AbstractDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.rankof-Tuple{AbstractDecomposition}"><code>BlockTensorFactorization.Core.rankof</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rankof(D::AbstractDecomposition)</code></pre><p>Internal dimension sizes for a decomposition. Returns the sizes of all factors if not defined for a concrete subtype of <code>AbstractDecomposition</code>.</p><p><strong>Examples</strong></p><p><code>CPDecomposition</code>: size of second dimension for the factors <code>Tucker</code>: size of the core factor <code>Tucker1</code>: size of the first dimension of the core factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L135-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.rankof-Tuple{CPDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.rankof-Tuple{CPDecomposition}"><code>BlockTensorFactorization.Core.rankof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The single rank for a CP Decomposition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/decomposition.jl#L467">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.reshape_ndims-Tuple{AbstractArray, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.reshape_ndims-Tuple{AbstractArray, Any}"><code>BlockTensorFactorization.Core.reshape_ndims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reshape_ndims(x, n)</code></pre><p>Reshapes <code>x</code> to a higher order array with <code>n</code> dimensions.</p><p>When n &gt; ndims(x), extra dimensions are prepended. Otherwise, trailing dimensions are collapsed.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; x = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; reshape_ndims(x, 1)
3-element Vector{Int64}:
 1
 2
 3

julia&gt; reshape_ndims(x, 2)
1×3 Matrix{Int64}:
 1  2  3

julia&gt; reshape_ndims(x, 3)
1×1×3 Array{Int64, 3}:
[:, :, 1] =
 1

[:, :, 2] =
 2

[:, :, 3] =
 3

julia&gt; A = reshape(collect(1:12), 2, 2, 3)
2×2×3 Array{Int64, 3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

[:, :, 3] =
  9  11
 10  12

julia&gt; reshape_ndims(A, 2)
2×6 Matrix{Int64}:
 1  3  5  7   9  11
 2  4  6  8  10  12</code></pre><p>Credit: https://discourse.julialang.org/t/outer-product-broadcast/103731/7</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L392-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.scale_constraint-Tuple{AbstractConstraint, Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.scale_constraint-Tuple{AbstractConstraint, Any, Any}"><code>BlockTensorFactorization.Core.scale_constraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scale_constraint(constraint::AbstractConstraint, scale, n_continuous_dims)</code></pre><p>Returns a scaled version of the constraint based off the number of relevant continuous dimensions the constraint acts on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/multiscale.jl#L403-L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.scale_constraints-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.scale_constraints-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.scale_constraints</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scale_constraints(Y, scale; kwargs...)</code></pre><p>Scales any constraints that need to be modified to use at a coarser scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/multiscale.jl#L197-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.scale_decomposition_constraint-Tuple{Any, Any, Any, CPDecomposition}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.scale_decomposition_constraint-Tuple{Any, Any, Any, CPDecomposition}"><code>BlockTensorFactorization.Core.scale_decomposition_constraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Idea is that external dimensions (I₁, I₂, ...) that are continuous dimensions need to be scaled, but internal dimensions (R₁, R₂, ...) or non-continuous dimensions don&#39;t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/multiscale.jl#L246-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.signed_circle_curvature-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.signed_circle_curvature-Tuple{Any, Any, Any}"><code>BlockTensorFactorization.Core.signed_circle_curvature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">signed_circle_curvature((a,f),(b,g),(c,h))</code></pre><p>Signed inverse radius of the circle passing through the 3 points in the xy-plane.</p><p>See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.three_point_circle"><code>three_point_circle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L277-L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.simplex!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.simplex!"><code>BlockTensorFactorization.Core.simplex!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simplex! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(isnonnegative_sumtoone, projsplx!; whats_normalized=identityslice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.simplex_12slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.simplex_12slices!"><code>BlockTensorFactorization.Core.simplex_12slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simplex_12slices! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(isnonnegative_sumtoone, projsplx!; whats_normalized=each12slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.simplex_1slices!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.simplex_1slices!"><code>BlockTensorFactorization.Core.simplex_1slices!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simplex_1slices! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(isnonnegative_sumtoone, projsplx!; whats_normalized=each1slice)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.simplex_cols!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.simplex_cols!"><code>BlockTensorFactorization.Core.simplex_cols!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simplex_cols! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(isnonnegative_sumtoone, projsplx!; whats_normalized=eachcol)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.simplex_rows!"><a class="docstring-binding" href="#BlockTensorFactorization.Core.simplex_rows!"><code>BlockTensorFactorization.Core.simplex_rows!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simplex_rows! &lt;: ProjectedNormalization</code></pre><p>Alias for</p><p><code>ProjectedNormalization(isnonnegative_sumtoone, projsplx!; whats_normalized=eachrow)</code>.</p><p>See <a href="../types/#BlockTensorFactorization.Core.ProjectedNormalization"><code>ProjectedNormalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/constraint.jl#L362-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.slicewise_dot-Tuple{AbstractArray, AbstractArray}"><code>BlockTensorFactorization.Core.slicewise_dot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">slicewise_dot(A::AbstractArray, B::AbstractArray; dims=1, dimsA=dims, dimsB=dims)</code></pre><p>Contracts all but the dimensions <code>dimsA</code> and <code>dimsB</code> of A and B. Entry-wise</p><p><code>(slicewise_dot(A,B; dimsA, dimsB))[i_dimsA, i_dimsB] = A[…, i_dimsA, ⋯] ⋅ B[…, i_dimsB, ⋯]</code>.</p><p>When <code>dims==n</code>, equivalent to <code>A ⋅ₙ B</code>. If A and B are both matrices, <code>slicewise_dot(A, B) == A&#39;B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L86-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.smart_insert!-Tuple{BlockedUpdate, AbstractUpdate}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.smart_insert!-Tuple{BlockedUpdate, AbstractUpdate}"><code>BlockTensorFactorization.Core.smart_insert!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smart_insert!(U::BlockedUpdate, V::AbstractUpdate)</code></pre><p>Tries to insert V into U after the last matching update in U. A &quot;matching update&quot; means it updates the same factor/block n. See <a href="#BlockTensorFactorization.Core.smart_interlace!-Tuple{BlockedUpdate, Any}"><code>smart_interlace!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/blockupdates.jl#L815-L821">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.smart_interlace!-Tuple{BlockedUpdate, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.smart_interlace!-Tuple{BlockedUpdate, Any}"><code>BlockTensorFactorization.Core.smart_interlace!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smart_interlace!(U::BlockedUpdate, V)</code></pre><p><code>smart_insert!</code>s each update in V, into U. See <a href="#BlockTensorFactorization.Core.smart_insert!-Tuple{BlockedUpdate, AbstractUpdate}"><code>smart_insert!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/blockupdates.jl#L831-L836">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.spline_mat-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.spline_mat-Tuple{Any}"><code>BlockTensorFactorization.Core.spline_mat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spline_mat(n)</code></pre><p>Creates the <code>Tridiagonal</code> matrix to solve for coefficients <code>b</code>. See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.cubic_spline_coefficients"><code>cubic_spline_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L92-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.standard_curvature-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.standard_curvature-Tuple{AbstractVector{&lt;:Real}}"><code>BlockTensorFactorization.Core.standard_curvature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">standard_curvature(y::AbstractVector{&lt;:Real}; method=:finite_differences)</code></pre><p>Approximates the signed curvature of a function, scaled to the unit box <span>$[0,1]^2$</span>.</p><p>Assumes the function is 1 at 0 and (after x dimension is scaled) 0 at 1.</p><p>See <a href="#BlockTensorFactorization.Core.curvature-Tuple{AbstractVector{&lt;:Real}}"><code>curvature</code></a>.</p><p><strong>Possible <code>method</code>s</strong></p><ul><li><code>:finite_differences</code>: Approximates first and second derivative with 3rd order finite differences. See <a href="#BlockTensorFactorization.Core.d_dx-Tuple{AbstractVector{&lt;:Real}}"><code>d_dx</code></a> and <a href="#BlockTensorFactorization.Core.d2_dx2-Tuple{AbstractVector{&lt;:Real}}"><code>d2_dx2</code></a>.</li><li><code>:splines</code>: Curvature of a third order spline. See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.d_dx_and_d2_dx2_spline"><code>d_dx_and_d2_dx2_spline</code></a>.</li><li><code>:circles</code>: Inverse radius of a circle through rolling three points. See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.circle_curvature"><code>circle_curvature</code></a>.</li><li><code>:breakpoints</code>: WARNING does not compute a value that approximates the curvature of a continuous function. Computes the inverse least-squares error of <code>f.(eachindex(y); z)</code> and <code>y</code> for all <code>z in eachindex(y)</code> where <code>f(x; z) = a + b(min(x, z) - z) + c(max(x, z) - z)</code>. Useful if <code>y</code> looks like two lines. See <a href="../../tutorial/rankestimation/#BlockTensorFactorization.Core.breakpoint_curvature"><code>breakpoint_curvature</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L175-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.swapdims"><a class="docstring-binding" href="#BlockTensorFactorization.Core.swapdims"><code>BlockTensorFactorization.Core.swapdims</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">swapdims(A::AbstractArray, a::Integer, b::Integer=1)</code></pre><p>Swap dimensions <code>a</code> and <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/utils.jl#L131-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.three_point_circle-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.three_point_circle-Tuple{Any, Any, Any}"><code>BlockTensorFactorization.Core.three_point_circle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">three_point_circle((a,f),(b,g),(c,h))</code></pre><p>Calculates radius <code>r</code> and center point <code>(p, q)</code> of the circle passing through the three points in the xy-plane.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">r, (p, q) = three_point_circle((1,2), (2,1), (5,2))
(r, (p, q)) == (√5, (3, 3))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/curvaturetools.jl#L246-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.tucker_contractions-Tuple{Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.tucker_contractions-Tuple{Any}"><code>BlockTensorFactorization.Core.tucker_contractions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tucker_contractions(N)</code></pre><p>Contractions used in a full Tucker decomposition of order N. This is a tuple of the n-mode products from 1 to N in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L136-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlockTensorFactorization.Core.tuckerproduct-Tuple{Any, Any}"><a class="docstring-binding" href="#BlockTensorFactorization.Core.tuckerproduct-Tuple{Any, Any}"><code>BlockTensorFactorization.Core.tuckerproduct</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tuckerproduct(G, (A, B, ...))
tuckerproduct(G, A, B, ...)</code></pre><p>Multiplies the inputs by treating the first argument as the core and the rest of the arguments as matrices in a Tucker decomposition.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">tuckerproduct(G, (A, B, C)) == G ×₁ A ×₂ B ×₃ C
tuckerproduct(G, (A, B, C); exclude=2) == G ×₁ A ×₃ C
tuckerproduct(G, (A, B, C); exclude=2, excludes_missing=false) == G ×₁ A ×₃ C
tuckerproduct(G, (A, C); exclude=2, excludes_missing=true) == G ×₁ A ×₃ C</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MPF-Optimization-Laboratory/BlockTensorFactorization.jl/blob/e4424e219bc960a2ccf481d612560b7043c87df7/src/Core/tensorproducts.jl#L144-L159">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 1 December 2025 18:35">Monday 1 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
